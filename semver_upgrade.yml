spec:
  inputs:
    version:
      description: "TEMPLATE VERSION"
      default: ''
    create_release:
      description: "CREATE RELEASE"
      type: boolean
      default: false
    sync_tags:
      description: "SYNC TAGS"
      type: boolean
      default: false

variables:
  GIT_STRATEGY: clone
  GIT_DEPTH: 50
  RETRY_COUNT: "2"

.semver_base:
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  before_script:
    - apt-get update && apt-get install -y git curl jq bash retry
    - git config --global user.name "GitLab CI"
    - git config --global user.email "gitlab-ci@${CI_SERVER_HOST}"
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git remote set-url origin "https://gitlab-ci-token:${GITLAB_BOT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - |
      if [ -z "$GITLAB_BOT_TOKEN" ]; then
        echo "ERROR: GITLAB_BOT_TOKEN is required"
        exit 1
      fi
    - |
      retry_cmd() {
        local n=0
        until "$@"; do
          n=$((n+1))
          if [ $n -ge ${RETRY_COUNT:-2} ]; then
            echo "ERROR: Command failed after $n attempts"
            return 1
          fi
          echo "Retrying ($n/${RETRY_COUNT}): $*"
          sleep 2
        done
      }

validate_version:
  extends: .semver_base
  stage: semver
  script:
    - |
      set -e
      echo "DEBUG: INPUT_VERSION=$INPUT_VERSION, CI_COMMIT_TAG=$CI_COMMIT_TAG, CI_COMMIT_SHA=$CI_COMMIT_SHA"
      
      # Determine version source
      if [ -n "${INPUT_VERSION:-}" ]; then
        TAG_NAME="$INPUT_VERSION"
        echo "DEBUG: Using INPUT_VERSION: $TAG_NAME"
      elif [ -n "${CI_COMMIT_TAG:-}" ]; then
        TAG_NAME="$CI_COMMIT_TAG"
        echo "DEBUG: Using CI_COMMIT_TAG: $TAG_NAME"
      else
        echo "ERROR: No INPUT_VERSION or CI_COMMIT_TAG provided"
        exit 1
      fi
      
      echo "Validating version: $TAG_NAME"
      
      # Validate semver format
      if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
        echo "ERROR: Invalid format. Expected: vX.Y.Z or vX.Y.Z-prerelease"
        exit 1
      fi
      
      # Parse version components
      VERSION_NO_V="${TAG_NAME#v}"
      BASE_VERSION=$(echo "$VERSION_NO_V" | sed 's/-.*//')
      IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
      
      # Determine release type
      if [[ "$TAG_NAME" =~ - ]]; then
        IS_PRERELEASE="true"
      else
        IS_PRERELEASE="false"
      fi
      
      echo "Version validated: $TAG_NAME (Major: $MAJOR, Minor: $MINOR, Patch: $PATCH, Prerelease: $IS_PRERELEASE)"
      
      echo "TAG_NAME=$TAG_NAME" > version.env
      echo "MAJOR=$MAJOR" >> version.env
      echo "MINOR=$MINOR" >> version.env
      echo "PATCH=$PATCH" >> version.env
      echo "IS_PRERELEASE=$IS_PRERELEASE" >> version.env
  artifacts:
    reports:
      dotenv: version.env
    expire_in: 1 hour
  rules:
    - if: '$INPUT_VERSION != "" || $CI_COMMIT_TAG != ""'

create_tag:
  extends: .semver_base
  stage: semver
  needs: [validate_version]
  script:
    - |
      set -e
      echo "DEBUG: Creating/updating tag: $TAG_NAME, CI_COMMIT_SHA=$CI_COMMIT_SHA"
      
      retry_cmd git fetch --all --tags
      
      # Check existing tag and update to latest commit
      if git tag -l | grep -q "^$TAG_NAME$"; then
        echo "Tag $TAG_NAME exists, updating to point to $CI_COMMIT_SHA"
        git tag -d "$TAG_NAME"
        retry_cmd git push origin ":refs/tags/$TAG_NAME"
      fi
      
      # Create and push tag to latest commit
      git tag -a "$TAG_NAME" "$CI_COMMIT_SHA" -m "Release $TAG_NAME"
      retry_cmd git push origin "$TAG_NAME"
      
      echo "Tag created/updated successfully: $TAG_NAME -> $CI_COMMIT_SHA"
  rules:
    - if: '$INPUT_VERSION != ""'

create_release:
  extends: .semver_base
  stage: semver
  needs:
    - job: validate_version
      optional: true
  script:
    - |
      set -e
      echo "DEBUG: INPUT_VERSION=$INPUT_VERSION, INPUT_CREATE_RELEASE=$INPUT_CREATE_RELEASE, CI_COMMIT_SHA=$CI_COMMIT_SHA"
      
      if [ -z "${TAG_NAME:-}" ]; then
        echo "No TAG_NAME provided, finding latest tag"
        retry_cmd git fetch --all --tags
        TAG_NAME=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$' | sort -V | tail -1)
        if [ -z "$TAG_NAME" ]; then
          echo "ERROR: No tags found"
          exit 1
        fi
        echo "DEBUG: Using latest tag: $TAG_NAME"
      
        # Parse version components
        VERSION_NO_V="${TAG_NAME#v}"
        BASE_VERSION=$(echo "$VERSION_NO_V" | sed 's/-.*//')
        IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
      
        # Determine release type
        if [[ "$TAG_NAME" =~ - ]]; then
          IS_PRERELEASE="true"
        else
          IS_PRERELEASE="false"
        fi
      fi
      
      echo "Creating/updating release: $TAG_NAME"
      
      # Verify tag exists
      retry_cmd git fetch --all --tags
      if ! git tag -l | grep -q "^$TAG_NAME$"; then
        echo "ERROR: Tag $TAG_NAME not found"
        exit 1
      fi
      
      # Build release description
      DESCRIPTION="Black Duck Security Scan $TAG_NAME"
      
      # Check existing release
      EXISTING=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
        "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$TAG_NAME" 2>/dev/null || echo "null")
      
      if [ "$EXISTING" != "null" ] && [ "$EXISTING" != "" ]; then
        echo "Release already exists, updating"
        # Delete existing release to update
        retry_cmd curl -s --fail-with-body \
          --request DELETE \
          --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
          "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$TAG_NAME" > "/dev/null"
      fi
      
      # Set release status
      if [ "$IS_PRERELEASE" = "true" ]; then
        RELEASED_AT="null"
        echo "Creating draft release (prerelease)"
      else
        RELEASED_AT="\"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\""
        echo "Creating published release"
      fi
      
      # Create release
      PAYLOAD=$(jq -nc \
        --arg name "Release $TAG_NAME" \
        --arg tag "$TAG_NAME" \
        --arg desc "$DESCRIPTION" \
        --argjson released "$RELEASED_AT" \
        '{name: $name, tag_name: $tag, description: $desc, released_at: $released}')
      
      retry_cmd curl -s --fail-with-body \
        --request POST \
        --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
        --header "Content-Type: application/json" \
        --data "$PAYLOAD" \
        "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases" > "/dev/null"
      
      echo "Release created/updated: $CI_PROJECT_URL/-/releases/$TAG_NAME"
  rules:
    - if: '$INPUT_VERSION != "" || $INPUT_CREATE_RELEASE == "true"'

sync_tags:
  extends: .semver_base
  stage: semver
  needs:
    - job: validate_version
      optional: true
  script:
    - |
      set -e
      echo "DEBUG: INPUT_VERSION=$INPUT_VERSION, INPUT_SYNC_TAGS=$INPUT_SYNC_TAGS, CI_COMMIT_SHA=$CI_COMMIT_SHA"
      
      # Determine sync target
      if [ -n "${TAG_NAME:-}" ]; then
        SYNC_TAG="$TAG_NAME"
        echo "DEBUG: Using TAG_NAME: $SYNC_TAG"
      else
        echo "Finding latest published release"
        SYNC_TAG=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
          "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases" | \
          jq -r 'map(select(.released_at != null)) | sort_by(.released_at) | reverse | .[0].tag_name // empty')
      
        if [ -z "$SYNC_TAG" ]; then
          echo "No published releases found"
          exit 0
        fi
        echo "DEBUG: Using latest published release: $SYNC_TAG"
      fi
      
      echo "Syncing tags for: $SYNC_TAG"
      
      # Verify release exists and is published
      if [ -n "${TAG_NAME:-}" ]; then
        RELEASE_EXISTS=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
          "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$SYNC_TAG" 2>/dev/null || echo "null")
      
        if [ "$RELEASE_EXISTS" = "null" ] || [ "$RELEASE_EXISTS" = "" ]; then
          echo "ERROR: No release found for tag $SYNC_TAG"
          exit 1
        fi
      
        IS_PUBLISHED=$(echo "$RELEASE_EXISTS" | jq -r '.released_at // empty')
        if [ -z "$IS_PUBLISHED" ] || [ "$IS_PUBLISHED" = "null" ]; then
          echo "Release is draft, skipping sync"
          exit 0
        fi
      fi
      
      # Skip prereleases
      if [[ "$SYNC_TAG" =~ - ]]; then
        echo "Skipping prerelease sync"
        exit 0
      fi
      
      # Validate format
      if [[ ! "$SYNC_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Invalid release tag format"
        exit 0
      fi
      
      retry_cmd git fetch --all --tags
      
      # Verify tag exists
      if ! git tag -l | grep -q "^$SYNC_TAG$"; then
        echo "ERROR: Tag $SYNC_TAG not found"
        exit 1
      fi
      
      # Get target commit (use CI_COMMIT_SHA for INPUT_VERSION, else tag's commit)
      if [ -n "${INPUT_VERSION:-}" ]; then
        TAG_COMMIT="$CI_COMMIT_SHA"
        echo "DEBUG: Using CI_COMMIT_SHA for INPUT_VERSION: $TAG_COMMIT"
      else
        TAG_COMMIT=$(git rev-list -n 1 "$SYNC_TAG")
        echo "DEBUG: Using tag commit for $SYNC_TAG: $TAG_COMMIT"
      fi
      
      # Update major tag
      VERSION_NO_V="${SYNC_TAG#v}"
      IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NO_V"
      MAJOR_TAG="v$MAJOR"
      echo "Updating major tag: $MAJOR_TAG"
      
      if git tag -l | grep -q "^$MAJOR_TAG$"; then
        git tag -d "$MAJOR_TAG"
        retry_cmd git push origin ":refs/tags/$MAJOR_TAG"
      fi
      
      git tag -a "$MAJOR_TAG" "$TAG_COMMIT" -m "Major version tag for $SYNC_TAG"
      retry_cmd git push origin "$MAJOR_TAG"
      
      # Update latest tag
      echo "Updating latest tag"
      
      if git tag -l | grep -q "^latest$"; then
        git tag -d "latest"
        retry_cmd git push origin ":refs/tags/latest"
      fi
      
      git tag -a "latest" "$TAG_COMMIT" -m "Latest stable release: $SYNC_TAG"
      retry_cmd git push origin "latest"
      
      echo "Tags synchronized: $MAJOR_TAG, latest -> ${TAG_COMMIT:0:8}"
  rules:
    - if: '$INPUT_VERSION != "" || $INPUT_SYNC_TAGS == "true"'
