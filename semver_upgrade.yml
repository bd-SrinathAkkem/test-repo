stages:
  - validate
  - tag
  - release
  - sync
  - cleanup

variables:
  GIT_STRATEGY: clone
  GIT_DEPTH: 50
  RETRY_COUNT: "2"

.semver_base:
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  before_script:
    - apt-get update && apt-get install -y git curl jq bash retry
    - git config --global user.name "GitLab CI"
    - git config --global user.email "gitlab-ci@${CI_SERVER_HOST}"
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git remote set-url origin "https://gitlab-ci-token:${GITLAB_BOT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - |
      if [ -z "$GITLAB_BOT_TOKEN" ]; then
        echo "ERROR: GITLAB_BOT_TOKEN is required"
        exit 1
      fi
    - |
      retry_cmd() {
        local n=0
        until "$@"; do
          n=$((n+1))
          if [ $n -ge ${RETRY_COUNT:-2} ]; then
            echo "ERROR: Command failed after $n attempts"
            return 1
          fi
          echo "Retrying ($n/${RETRY_COUNT}): $*"
          sleep 2
        done
      }


validate_version:
  extends: .semver_base
  stage: validate
  script:
    - |
      set -e
      
      # Determine version source
      if [ -n "${VERSION:-}" ]; then
        TAG_NAME="$VERSION"
      elif [ -n "${CI_COMMIT_TAG:-}" ]; then
        TAG_NAME="$CI_COMMIT_TAG"
      else
        echo "ERROR: No VERSION variable or tag provided"
        exit 1
      fi
      
      echo "Validating version: $TAG_NAME"
      
      # Validate semver format
      if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
        echo "ERROR: Invalid format. Expected: vX.Y.Z or vX.Y.Z-prerelease"
        exit 1
      fi
      
      # Parse version components
      VERSION_NO_V="${TAG_NAME#v}"
      BASE_VERSION=$(echo "$VERSION_NO_V" | sed 's/-.*//')
      IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
      
      # Determine release type
      if [[ "$TAG_NAME" =~ - ]]; then
        IS_PRERELEASE="true"
      else
        IS_PRERELEASE="false"
      fi
      
      echo "Version validated: $TAG_NAME (Major: $MAJOR, Minor: $MINOR, Patch: $PATCH, Prerelease: $IS_PRERELEASE)"
      
      
      echo "TAG_NAME=$TAG_NAME" > version.env
      echo "MAJOR=$MAJOR" >> version.env
      echo "MINOR=$MINOR" >> version.env
      echo "PATCH=$PATCH" >> version.env
      echo "IS_PRERELEASE=$IS_PRERELEASE" >> version.env
  artifacts:
    reports:
      dotenv: version.env
    expire_in: 1 hour
  rules:
    - if: '$VERSION'
    - if: '$CI_COMMIT_TAG'

create_tag:
  extends: .semver_base
  stage: tag
  needs: [validate_version]
  script:
    - |
      set -e
      echo "Creating tag: $TAG_NAME"
      
      retry_cmd git fetch --all --tags
      
      # Check existing tag
      if git tag -l | grep -q "^$TAG_NAME$"; then
        if [ "${FORCE_RECREATE:-false}" != "true" ]; then
          echo "ERROR: Tag exists. Set FORCE_RECREATE=true to overwrite"
          exit 1
        fi
        echo "Recreating existing tag"
        git tag -d "$TAG_NAME"
        retry_cmd git push origin ":refs/tags/$TAG_NAME"
      fi
      
      # Create and push tag
      git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
      retry_cmd git push origin "$TAG_NAME"
      
      echo "Tag created successfully: $TAG_NAME"
  rules:
    - if: '$VERSION'

create_release:
  extends: .semver_base
  stage: release
  needs: [validate_version]
  script:
    - |
      set -e
      echo "Creating release: $TAG_NAME"
      
      # Verify tag exists
      retry_cmd git fetch --all --tags
      if ! git tag -l | grep -q "^$TAG_NAME$"; then
        echo "ERROR: Tag $TAG_NAME not found"
        exit 1
      fi
      
      # Build release description
      DESCRIPTION="Black Duck Security Scan $TAG_NAME"
      
      # Check existing release
      EXISTING=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
        "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$TAG_NAME" 2>/dev/null || echo "null")
      
        if [ "$EXISTING" != "null" ] && [ "$EXISTING" != "" ]; then
        if [ "${FORCE_RECREATE:-false}" != "true" ]; then
        echo "Release already exists, skipping"
        exit 0
        fi
        echo "Updating existing release"
        fi
        
        # Set release status
        if [ "$IS_PRERELEASE" = "true" ]; then
        RELEASED_AT="null"
        echo "Creating draft release (prerelease)"
        else
        RELEASED_AT="\"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\""
        echo "Creating published release"
        fi
        
        # Create release
        PAYLOAD=$(jq -nc \
        --arg name "Release $TAG_NAME" \
        --arg tag "$TAG_NAME" \
        --arg desc "$DESCRIPTION" \
        --argjson released "$RELEASED_AT" \
        '{name: $name, tag_name: $tag, description: $desc, released_at: $released}')
        
        retry_cmd curl -s --fail-with-body \
        --request POST \
      --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
      --header "Content-Type: application/json" \
        --data "$PAYLOAD" \
        "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases" > "/dev/null"
      
      echo "Release created: $CI_PROJECT_URL/-/releases/$TAG_NAME"
      rules:
        - if: '$CREATE_RELEASE == "true"'

sync_tags:
  extends: .semver_base
  stage: sync
  needs: [validate_version]
  script:
    - |
      set -e
      
      # Determine sync target
      if [ -n "${TAG_NAME:-}" ]; then
        SYNC_TAG="$TAG_NAME"
      else
        echo "Finding latest published release"
        SYNC_TAG=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
          "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases" | \
          jq -r 'map(select(.released_at != null)) | sort_by(.released_at) | reverse | .[0].tag_name // empty')
      
        if [ -z "$SYNC_TAG" ]; then
          echo "No published releases found"
          exit 0
        fi
      fi
      
      echo "Syncing tags for: $SYNC_TAG"
      
      # Verify release exists and is published
      if [ -n "${TAG_NAME:-}" ]; then
        RELEASE_EXISTS=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_BOT_TOKEN" \
          "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$SYNC_TAG" 2>/dev/null || echo "null")
      
        if [ "$RELEASE_EXISTS" = "null" ] || [ "$RELEASE_EXISTS" = "" ]; then
          echo "ERROR: No release found for tag $SYNC_TAG"
          exit 1
        fi
      
        IS_PUBLISHED=$(echo "$RELEASE_EXISTS" | jq -r '.released_at // empty')
        if [ -z "$IS_PUBLISHED" ] || [ "$IS_PUBLISHED" = "null" ]; then
          echo "Release is draft, skipping sync"
          exit 0
        fi
      fi
      
      # Skip prereleases
      if [[ "$SYNC_TAG" =~ - ]]; then
        echo "Skipping prerelease sync"
        exit 0
      fi
      
      # Validate format
      if [[ ! "$SYNC_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Invalid release tag format"
        exit 0
      fi
      
      retry_cmd git fetch --all --tags
      
      # Verify tag exists
      if ! git tag -l | grep -q "^$SYNC_TAG$"; then
        echo "ERROR: Tag $SYNC_TAG not found"
        exit 1
      fi
      
      # Get target commit
      TAG_COMMIT=$(git rev-list -n 1 "$SYNC_TAG")
      VERSION_NO_V="${SYNC_TAG#v}"
      IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NO_V"
      
      # Update major tag
      MAJOR_TAG="v$MAJOR"
      echo "Updating major tag: $MAJOR_TAG"
      
      if git tag -l | grep -q "^$MAJOR_TAG$"; then
        git tag -d "$MAJOR_TAG"
        retry_cmd git push origin ":refs/tags/$MAJOR_TAG"
      fi
      
      git tag -a "$MAJOR_TAG" "$TAG_COMMIT" -m "Major version tag for $SYNC_TAG"
      retry_cmd git push origin "$MAJOR_TAG"
      
      # Update latest tag
      echo "Updating latest tag"
      
      if git tag -l | grep -q "^latest$"; then
        git tag -d "latest"
        retry_cmd git push origin ":refs/tags/latest"
      fi
      
      git tag -a "latest" "$TAG_COMMIT" -m "Latest stable release: $SYNC_TAG"
      retry_cmd git push origin "latest"
      
      echo "Tags synchronized: $MAJOR_TAG, latest -> ${TAG_COMMIT:0:8}"
  rules:
    - if: '$SYNC_TAGS == "true"'

cleanup_prereleases:
  extends: .semver_base
  stage: cleanup
  script:
    - |
      set -e
      echo "Cleaning up prerelease tags"
      
      retry_cmd git fetch --all --tags
      
      # Find prereleases
      PRERELEASE_TAGS=$(git tag -l | grep -E '\-(alpha|beta|rc|dev)' | sort -V || true)
      
      if [ -z "$PRERELEASE_TAGS" ]; then
        echo "No prerelease tags found"
        exit 0
      fi
      
      TAG_COUNT=$(echo "$PRERELEASE_TAGS" | wc -l)
      KEEP_COUNT=${KEEP_PRERELEASES:-5}
      
      if [ $TAG_COUNT -le $KEEP_COUNT ]; then
        echo "Keeping all $TAG_COUNT prerelease tags"
        exit 0
      fi
      
      DELETE_COUNT=$((TAG_COUNT - KEEP_COUNT))
      TAGS_TO_DELETE=$(echo "$PRERELEASE_TAGS" | head -n $DELETE_COUNT)
      
      echo "Deleting $DELETE_COUNT old prerelease tags"
      
      echo "$TAGS_TO_DELETE" | while read -r tag; do
        if [ -n "$tag" ]; then
          retry_cmd git push origin ":refs/tags/$tag" || echo "Failed to delete $tag"
        fi
      done
      
      echo "Cleanup completed"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
  allow_failure: true
